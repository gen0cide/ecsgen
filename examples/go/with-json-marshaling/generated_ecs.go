// Code generated by ecsgen; DO NOT EDIT.
package main

import (
	"encoding/json"
	"reflect"
	"time"
)

// Base defines the top level Elastic Common Schema (ECS) type. This type should be the default for interacting with ECS data, including the marshaling and unmarshaling of it.
type Base struct {
	AtTimestamp   time.Time              `json:"@timestamp,omitempty" yaml:"@timestamp,omitempty" ecs:"@timestamp"`
	Labels        map[string]interface{} `json:"labels,omitempty" yaml:"labels,omitempty" ecs:"labels"`
	Message       string                 `json:"message,omitempty" yaml:"message,omitempty" ecs:"message"`
	Tags          []string               `json:"tags,omitempty" yaml:"tags,omitempty" ecs:"tags"`
	Agent         Agent                  `json:"agent,omitempty" yaml:"agent,omitempty" ecs:"agent"`
	AS            AS                     `json:"as,omitempty" yaml:"as,omitempty" ecs:"as"`
	Client        Client                 `json:"client,omitempty" yaml:"client,omitempty" ecs:"client"`
	Cloud         Cloud                  `json:"cloud,omitempty" yaml:"cloud,omitempty" ecs:"cloud"`
	CodeSignature CodeSignature          `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"code_signature"`
	Container     Container              `json:"container,omitempty" yaml:"container,omitempty" ecs:"container"`
	Destination   Destination            `json:"destination,omitempty" yaml:"destination,omitempty" ecs:"destination"`
	DLL           DLL                    `json:"dll,omitempty" yaml:"dll,omitempty" ecs:"dll"`
	DNS           DNS                    `json:"dns,omitempty" yaml:"dns,omitempty" ecs:"dns"`
	ECS           ECS                    `json:"ecs,omitempty" yaml:"ecs,omitempty" ecs:"ecs"`
	Error         Error                  `json:"error,omitempty" yaml:"error,omitempty" ecs:"error"`
	Event         Event                  `json:"event,omitempty" yaml:"event,omitempty" ecs:"event"`
	File          File                   `json:"file,omitempty" yaml:"file,omitempty" ecs:"file"`
	Geo           Geo                    `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"geo"`
	Group         Group                  `json:"group,omitempty" yaml:"group,omitempty" ecs:"group"`
	Hash          Hash                   `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"hash"`
	Host          Host                   `json:"host,omitempty" yaml:"host,omitempty" ecs:"host"`
	HTTP          HTTP                   `json:"http,omitempty" yaml:"http,omitempty" ecs:"http"`
	Interface     Interface              `json:"interface,omitempty" yaml:"interface,omitempty" ecs:"interface"`
	Log           Log                    `json:"log,omitempty" yaml:"log,omitempty" ecs:"log"`
	Network       Network                `json:"network,omitempty" yaml:"network,omitempty" ecs:"network"`
	Observer      Observer               `json:"observer,omitempty" yaml:"observer,omitempty" ecs:"observer"`
	Organization  Organization           `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"organization"`
	OS            OS                     `json:"os,omitempty" yaml:"os,omitempty" ecs:"os"`
	Package       Package                `json:"package,omitempty" yaml:"package,omitempty" ecs:"package"`
	PE            PE                     `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"pe"`
	Process       Process                `json:"process,omitempty" yaml:"process,omitempty" ecs:"process"`
	Registry      Registry               `json:"registry,omitempty" yaml:"registry,omitempty" ecs:"registry"`
	Related       Related                `json:"related,omitempty" yaml:"related,omitempty" ecs:"related"`
	Rule          Rule                   `json:"rule,omitempty" yaml:"rule,omitempty" ecs:"rule"`
	Search        Search                 `json:"search,omitempty" yaml:"search,omitempty" ecs:"search"`
	Server        Server                 `json:"server,omitempty" yaml:"server,omitempty" ecs:"server"`
	Service       Service                `json:"service,omitempty" yaml:"service,omitempty" ecs:"service"`
	Source        Source                 `json:"source,omitempty" yaml:"source,omitempty" ecs:"source"`
	Threat        Threat                 `json:"threat,omitempty" yaml:"threat,omitempty" ecs:"threat"`
	TLS           TLS                    `json:"tls,omitempty" yaml:"tls,omitempty" ecs:"tls"`
	Trace         Trace                  `json:"trace,omitempty" yaml:"trace,omitempty" ecs:"trace"`
	Transaction   Transaction            `json:"transaction,omitempty" yaml:"transaction,omitempty" ecs:"transaction"`
	URL           URL                    `json:"url,omitempty" yaml:"url,omitempty" ecs:"url"`
	User          User                   `json:"user,omitempty" yaml:"user,omitempty" ecs:"user"`
	UserAgent     UserAgent              `json:"user_agent,omitempty" yaml:"user_agent,omitempty" ecs:"user_agent"`
	VLAN          VLAN                   `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"vlan"`
	Vulnerability Vulnerability          `json:"vulnerability,omitempty" yaml:"vulnerability,omitempty" ecs:"vulnerability"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Base) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.AtTimestamp); !val.IsZero() {
		res["@timestamp"] = b.AtTimestamp
	}

	if val := reflect.ValueOf(b.Labels); !val.IsZero() {
		res["labels"] = b.Labels
	}

	if val := reflect.ValueOf(b.Message); !val.IsZero() {
		res["message"] = b.Message
	}

	if val := reflect.ValueOf(b.Tags); !val.IsZero() {
		res["tags"] = b.Tags
	}

	if val := reflect.ValueOf(b.Agent); !val.IsZero() {
		res["agent"] = b.Agent
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Client); !val.IsZero() {
		res["client"] = b.Client
	}

	if val := reflect.ValueOf(b.Cloud); !val.IsZero() {
		res["cloud"] = b.Cloud
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.Container); !val.IsZero() {
		res["container"] = b.Container
	}

	if val := reflect.ValueOf(b.Destination); !val.IsZero() {
		res["destination"] = b.Destination
	}

	if val := reflect.ValueOf(b.DLL); !val.IsZero() {
		res["dll"] = b.DLL
	}

	if val := reflect.ValueOf(b.DNS); !val.IsZero() {
		res["dns"] = b.DNS
	}

	if val := reflect.ValueOf(b.ECS); !val.IsZero() {
		res["ecs"] = b.ECS
	}

	if val := reflect.ValueOf(b.Error); !val.IsZero() {
		res["error"] = b.Error
	}

	if val := reflect.ValueOf(b.Event); !val.IsZero() {
		res["event"] = b.Event
	}

	if val := reflect.ValueOf(b.File); !val.IsZero() {
		res["file"] = b.File
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Host); !val.IsZero() {
		res["host"] = b.Host
	}

	if val := reflect.ValueOf(b.HTTP); !val.IsZero() {
		res["http"] = b.HTTP
	}

	if val := reflect.ValueOf(b.Interface); !val.IsZero() {
		res["interface"] = b.Interface
	}

	if val := reflect.ValueOf(b.Log); !val.IsZero() {
		res["log"] = b.Log
	}

	if val := reflect.ValueOf(b.Network); !val.IsZero() {
		res["network"] = b.Network
	}

	if val := reflect.ValueOf(b.Observer); !val.IsZero() {
		res["observer"] = b.Observer
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Package); !val.IsZero() {
		res["package"] = b.Package
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.Process); !val.IsZero() {
		res["process"] = b.Process
	}

	if val := reflect.ValueOf(b.Registry); !val.IsZero() {
		res["registry"] = b.Registry
	}

	if val := reflect.ValueOf(b.Related); !val.IsZero() {
		res["related"] = b.Related
	}

	if val := reflect.ValueOf(b.Rule); !val.IsZero() {
		res["rule"] = b.Rule
	}

	if val := reflect.ValueOf(b.Search); !val.IsZero() {
		res["search"] = b.Search
	}

	if val := reflect.ValueOf(b.Server); !val.IsZero() {
		res["server"] = b.Server
	}

	if val := reflect.ValueOf(b.Service); !val.IsZero() {
		res["service"] = b.Service
	}

	if val := reflect.ValueOf(b.Source); !val.IsZero() {
		res["source"] = b.Source
	}

	if val := reflect.ValueOf(b.Threat); !val.IsZero() {
		res["threat"] = b.Threat
	}

	if val := reflect.ValueOf(b.TLS); !val.IsZero() {
		res["tls"] = b.TLS
	}

	if val := reflect.ValueOf(b.Trace); !val.IsZero() {
		res["trace"] = b.Trace
	}

	if val := reflect.ValueOf(b.Transaction); !val.IsZero() {
		res["transaction"] = b.Transaction
	}

	if val := reflect.ValueOf(b.URL); !val.IsZero() {
		res["url"] = b.URL
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	if val := reflect.ValueOf(b.UserAgent); !val.IsZero() {
		res["user_agent"] = b.UserAgent
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	if val := reflect.ValueOf(b.Vulnerability); !val.IsZero() {
		res["vulnerability"] = b.Vulnerability
	}

	return json.Marshal(res)
}

// Agent defines the object located at ECS path agent.
type Agent struct {
	EphemeralID string `json:"ephemeral_id,omitempty" yaml:"ephemeral_id,omitempty" ecs:"agent.ephemeral_id"`
	ID          string `json:"id,omitempty" yaml:"id,omitempty" ecs:"agent.id"`
	Name        string `json:"name,omitempty" yaml:"name,omitempty" ecs:"agent.name"`
	Type        string `json:"type,omitempty" yaml:"type,omitempty" ecs:"agent.type"`
	Version     string `json:"version,omitempty" yaml:"version,omitempty" ecs:"agent.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Agent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.EphemeralID); !val.IsZero() {
		res["ephemeral_id"] = b.EphemeralID
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// AS defines the object located at ECS path as.
type AS struct {
	Number       int64          `json:"number,omitempty" yaml:"number,omitempty" ecs:"as.number"`
	Organization ASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b AS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// ASOrganization defines the object located at ECS path as.organization.
type ASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Client defines the object located at ECS path client.
type Client struct {
	Address          string     `json:"address,omitempty" yaml:"address,omitempty" ecs:"client.address"`
	AS               ClientAS   `json:"as,omitempty" yaml:"as,omitempty" ecs:"client.as"`
	Bytes            int64      `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"client.bytes"`
	Domain           string     `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.domain"`
	Geo              ClientGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"client.geo"`
	IP               string     `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"client.ip"`
	MAC              string     `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"client.mac"`
	NAT              ClientNAT  `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"client.nat"`
	Packets          int64      `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"client.packets"`
	Port             int64      `json:"port,omitempty" yaml:"port,omitempty" ecs:"client.port"`
	RegisteredDomain string     `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"client.registered_domain"`
	TopLevelDomain   string     `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"client.top_level_domain"`
	User             ClientUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"client.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Client) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// ClientAS defines the object located at ECS path client.as.
type ClientAS struct {
	Number       int64                `json:"number,omitempty" yaml:"number,omitempty" ecs:"client.as.number"`
	Organization ClientASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"client.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// ClientASOrganization defines the object located at ECS path client.as.organization.
type ClientASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ClientGeo defines the object located at ECS path client.geo.
type ClientGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"client.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"client.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"client.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"client.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"client.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"client.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"client.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// ClientNAT defines the object located at ECS path client.nat.
type ClientNAT struct {
	IP   string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"client.nat.ip"`
	Port int64  `json:"port,omitempty" yaml:"port,omitempty" ecs:"client.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// ClientUser defines the object located at ECS path client.user.
type ClientUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"client.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"client.user.full_name"`
	Group    ClientUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"client.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"client.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"client.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ClientUserGroup defines the object located at ECS path client.user.group.
type ClientUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"client.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Cloud defines the object located at ECS path cloud.
type Cloud struct {
	Account          CloudAccount  `json:"account,omitempty" yaml:"account,omitempty" ecs:"cloud.account"`
	AvailabilityZone string        `json:"availability_zone,omitempty" yaml:"availability_zone,omitempty" ecs:"cloud.availability_zone"`
	Instance         CloudInstance `json:"instance,omitempty" yaml:"instance,omitempty" ecs:"cloud.instance"`
	Machine          CloudMachine  `json:"machine,omitempty" yaml:"machine,omitempty" ecs:"cloud.machine"`
	Provider         string        `json:"provider,omitempty" yaml:"provider,omitempty" ecs:"cloud.provider"`
	Region           string        `json:"region,omitempty" yaml:"region,omitempty" ecs:"cloud.region"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Cloud) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Account); !val.IsZero() {
		res["account"] = b.Account
	}

	if val := reflect.ValueOf(b.AvailabilityZone); !val.IsZero() {
		res["availability_zone"] = b.AvailabilityZone
	}

	if val := reflect.ValueOf(b.Instance); !val.IsZero() {
		res["instance"] = b.Instance
	}

	if val := reflect.ValueOf(b.Machine); !val.IsZero() {
		res["machine"] = b.Machine
	}

	if val := reflect.ValueOf(b.Provider); !val.IsZero() {
		res["provider"] = b.Provider
	}

	if val := reflect.ValueOf(b.Region); !val.IsZero() {
		res["region"] = b.Region
	}

	return json.Marshal(res)
}

// CloudAccount defines the object located at ECS path cloud.account.
type CloudAccount struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"cloud.account.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudAccount) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// CloudInstance defines the object located at ECS path cloud.instance.
type CloudInstance struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"cloud.instance.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"cloud.instance.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudInstance) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// CloudMachine defines the object located at ECS path cloud.machine.
type CloudMachine struct {
	Type string `json:"type,omitempty" yaml:"type,omitempty" ecs:"cloud.machine.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudMachine) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// CodeSignature defines the object located at ECS path code_signature.
type CodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// Container defines the object located at ECS path container.
type Container struct {
	ID      string                 `json:"id,omitempty" yaml:"id,omitempty" ecs:"container.id"`
	Image   ContainerImage         `json:"image,omitempty" yaml:"image,omitempty" ecs:"container.image"`
	Labels  map[string]interface{} `json:"labels,omitempty" yaml:"labels,omitempty" ecs:"container.labels"`
	Name    string                 `json:"name,omitempty" yaml:"name,omitempty" ecs:"container.name"`
	Runtime string                 `json:"runtime,omitempty" yaml:"runtime,omitempty" ecs:"container.runtime"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Container) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Image); !val.IsZero() {
		res["image"] = b.Image
	}

	if val := reflect.ValueOf(b.Labels); !val.IsZero() {
		res["labels"] = b.Labels
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Runtime); !val.IsZero() {
		res["runtime"] = b.Runtime
	}

	return json.Marshal(res)
}

// ContainerImage defines the object located at ECS path container.image.
type ContainerImage struct {
	Name string   `json:"name,omitempty" yaml:"name,omitempty" ecs:"container.image.name"`
	Tag  []string `json:"tag,omitempty" yaml:"tag,omitempty" ecs:"container.image.tag"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ContainerImage) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Tag); !val.IsZero() {
		res["tag"] = b.Tag
	}

	return json.Marshal(res)
}

// Destination defines the object located at ECS path destination.
type Destination struct {
	Address          string          `json:"address,omitempty" yaml:"address,omitempty" ecs:"destination.address"`
	AS               DestinationAS   `json:"as,omitempty" yaml:"as,omitempty" ecs:"destination.as"`
	Bytes            int64           `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"destination.bytes"`
	Domain           string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.domain"`
	Geo              DestinationGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"destination.geo"`
	IP               string          `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"destination.ip"`
	MAC              string          `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"destination.mac"`
	NAT              DestinationNAT  `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"destination.nat"`
	Packets          int64           `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"destination.packets"`
	Port             int64           `json:"port,omitempty" yaml:"port,omitempty" ecs:"destination.port"`
	RegisteredDomain string          `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"destination.registered_domain"`
	TopLevelDomain   string          `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"destination.top_level_domain"`
	User             DestinationUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"destination.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Destination) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// DestinationAS defines the object located at ECS path destination.as.
type DestinationAS struct {
	Number       int64                     `json:"number,omitempty" yaml:"number,omitempty" ecs:"destination.as.number"`
	Organization DestinationASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"destination.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// DestinationASOrganization defines the object located at ECS path destination.as.organization.
type DestinationASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// DestinationGeo defines the object located at ECS path destination.geo.
type DestinationGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"destination.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"destination.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"destination.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"destination.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"destination.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"destination.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"destination.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// DestinationNAT defines the object located at ECS path destination.nat.
type DestinationNAT struct {
	IP   string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"destination.nat.ip"`
	Port int64  `json:"port,omitempty" yaml:"port,omitempty" ecs:"destination.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// DestinationUser defines the object located at ECS path destination.user.
type DestinationUser struct {
	Domain   string               `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.user.domain"`
	Email    string               `json:"email,omitempty" yaml:"email,omitempty" ecs:"destination.user.email"`
	FullName string               `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"destination.user.full_name"`
	Group    DestinationUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"destination.user.group"`
	Hash     string               `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"destination.user.hash"`
	ID       string               `json:"id,omitempty" yaml:"id,omitempty" ecs:"destination.user.id"`
	Name     string               `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// DestinationUserGroup defines the object located at ECS path destination.user.group.
type DestinationUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"destination.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// DLL defines the object located at ECS path dll.
type DLL struct {
	CodeSignature DLLCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"dll.code_signature"`
	Hash          DLLHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"dll.hash"`
	Name          string           `json:"name,omitempty" yaml:"name,omitempty" ecs:"dll.name"`
	Path          string           `json:"path,omitempty" yaml:"path,omitempty" ecs:"dll.path"`
	PE            DLLPE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"dll.pe"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLL) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	return json.Marshal(res)
}

// DLLCodeSignature defines the object located at ECS path dll.code_signature.
type DLLCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"dll.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"dll.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"dll.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"dll.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"dll.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// DLLHash defines the object located at ECS path dll.hash.
type DLLHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"dll.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"dll.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"dll.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"dll.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// DLLPE defines the object located at ECS path dll.pe.
type DLLPE struct {
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"dll.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"dll.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"dll.pe.file_version"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"dll.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"dll.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLPE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// DNS defines the object located at ECS path dns.
type DNS struct {
	Answers      []DNSAnswers `json:"answers,omitempty" yaml:"answers,omitempty" ecs:"dns.answers"`
	HeaderFlags  []string     `json:"header_flags,omitempty" yaml:"header_flags,omitempty" ecs:"dns.header_flags"`
	ID           string       `json:"id,omitempty" yaml:"id,omitempty" ecs:"dns.id"`
	OpCode       string       `json:"op_code,omitempty" yaml:"op_code,omitempty" ecs:"dns.op_code"`
	Question     DNSQuestion  `json:"question,omitempty" yaml:"question,omitempty" ecs:"dns.question"`
	ResolvedIP   []string     `json:"resolved_ip,omitempty" yaml:"resolved_ip,omitempty" ecs:"dns.resolved_ip"`
	ResponseCode string       `json:"response_code,omitempty" yaml:"response_code,omitempty" ecs:"dns.response_code"`
	Type         string       `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Answers); !val.IsZero() {
		res["answers"] = b.Answers
	}

	if val := reflect.ValueOf(b.HeaderFlags); !val.IsZero() {
		res["header_flags"] = b.HeaderFlags
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.OpCode); !val.IsZero() {
		res["op_code"] = b.OpCode
	}

	if val := reflect.ValueOf(b.Question); !val.IsZero() {
		res["question"] = b.Question
	}

	if val := reflect.ValueOf(b.ResolvedIP); !val.IsZero() {
		res["resolved_ip"] = b.ResolvedIP
	}

	if val := reflect.ValueOf(b.ResponseCode); !val.IsZero() {
		res["response_code"] = b.ResponseCode
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// DNSAnswers defines the object located at ECS path dns.answers.
type DNSAnswers struct {
	Class string `json:"class,omitempty" yaml:"class,omitempty" ecs:"dns.answers.class"`
	Data  string `json:"data,omitempty" yaml:"data,omitempty" ecs:"dns.answers.data"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"dns.answers.name"`
	TTL   int64  `json:"ttl,omitempty" yaml:"ttl,omitempty" ecs:"dns.answers.ttl"`
	Type  string `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.answers.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNSAnswers) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Class); !val.IsZero() {
		res["class"] = b.Class
	}

	if val := reflect.ValueOf(b.Data); !val.IsZero() {
		res["data"] = b.Data
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.TTL); !val.IsZero() {
		res["ttl"] = b.TTL
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// DNSQuestion defines the object located at ECS path dns.question.
type DNSQuestion struct {
	Class            string `json:"class,omitempty" yaml:"class,omitempty" ecs:"dns.question.class"`
	Name             string `json:"name,omitempty" yaml:"name,omitempty" ecs:"dns.question.name"`
	RegisteredDomain string `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"dns.question.registered_domain"`
	Subdomain        string `json:"subdomain,omitempty" yaml:"subdomain,omitempty" ecs:"dns.question.subdomain"`
	TopLevelDomain   string `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"dns.question.top_level_domain"`
	Type             string `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.question.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNSQuestion) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Class); !val.IsZero() {
		res["class"] = b.Class
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.Subdomain); !val.IsZero() {
		res["subdomain"] = b.Subdomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// ECS defines the object located at ECS path ecs.
type ECS struct {
	Version string `json:"version,omitempty" yaml:"version,omitempty" ecs:"ecs.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ECS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Error defines the object located at ECS path error.
type Error struct {
	Code       string `json:"code,omitempty" yaml:"code,omitempty" ecs:"error.code"`
	ID         string `json:"id,omitempty" yaml:"id,omitempty" ecs:"error.id"`
	Message    string `json:"message,omitempty" yaml:"message,omitempty" ecs:"error.message"`
	StackTrace string `json:"stack_trace,omitempty" yaml:"stack_trace,omitempty" ecs:"error.stack_trace"`
	Type       string `json:"type,omitempty" yaml:"type,omitempty" ecs:"error.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Error) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Message); !val.IsZero() {
		res["message"] = b.Message
	}

	if val := reflect.ValueOf(b.StackTrace); !val.IsZero() {
		res["stack_trace"] = b.StackTrace
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// Event defines the object located at ECS path event.
type Event struct {
	Action        string        `json:"action,omitempty" yaml:"action,omitempty" ecs:"event.action"`
	Category      []string      `json:"category,omitempty" yaml:"category,omitempty" ecs:"event.category"`
	Code          string        `json:"code,omitempty" yaml:"code,omitempty" ecs:"event.code"`
	Created       time.Time     `json:"created,omitempty" yaml:"created,omitempty" ecs:"event.created"`
	Dataset       string        `json:"dataset,omitempty" yaml:"dataset,omitempty" ecs:"event.dataset"`
	Duration      time.Duration `json:"duration,omitempty" yaml:"duration,omitempty" ecs:"event.duration"`
	End           time.Time     `json:"end,omitempty" yaml:"end,omitempty" ecs:"event.end"`
	Hash          string        `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"event.hash"`
	ID            string        `json:"id,omitempty" yaml:"id,omitempty" ecs:"event.id"`
	Ingested      time.Time     `json:"ingested,omitempty" yaml:"ingested,omitempty" ecs:"event.ingested"`
	Kind          string        `json:"kind,omitempty" yaml:"kind,omitempty" ecs:"event.kind"`
	Module        string        `json:"module,omitempty" yaml:"module,omitempty" ecs:"event.module"`
	Original      string        `json:"original,omitempty" yaml:"original,omitempty" ecs:"event.original"`
	Outcome       string        `json:"outcome,omitempty" yaml:"outcome,omitempty" ecs:"event.outcome"`
	Provider      string        `json:"provider,omitempty" yaml:"provider,omitempty" ecs:"event.provider"`
	Reference     string        `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"event.reference"`
	RiskScore     float64       `json:"risk_score,omitempty" yaml:"risk_score,omitempty" ecs:"event.risk_score"`
	RiskScoreNorm float64       `json:"risk_score_norm,omitempty" yaml:"risk_score_norm,omitempty" ecs:"event.risk_score_norm"`
	Sequence      int64         `json:"sequence,omitempty" yaml:"sequence,omitempty" ecs:"event.sequence"`
	Severity      int64         `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"event.severity"`
	Start         time.Time     `json:"start,omitempty" yaml:"start,omitempty" ecs:"event.start"`
	Timezone      string        `json:"timezone,omitempty" yaml:"timezone,omitempty" ecs:"event.timezone"`
	Type          []string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"event.type"`
	URL           string        `json:"url,omitempty" yaml:"url,omitempty" ecs:"event.url"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Event) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Action); !val.IsZero() {
		res["action"] = b.Action
	}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Created); !val.IsZero() {
		res["created"] = b.Created
	}

	if val := reflect.ValueOf(b.Dataset); !val.IsZero() {
		res["dataset"] = b.Dataset
	}

	if val := reflect.ValueOf(b.Duration); !val.IsZero() {
		res["duration"] = b.Duration
	}

	if val := reflect.ValueOf(b.End); !val.IsZero() {
		res["end"] = b.End
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Ingested); !val.IsZero() {
		res["ingested"] = b.Ingested
	}

	if val := reflect.ValueOf(b.Kind); !val.IsZero() {
		res["kind"] = b.Kind
	}

	if val := reflect.ValueOf(b.Module); !val.IsZero() {
		res["module"] = b.Module
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Outcome); !val.IsZero() {
		res["outcome"] = b.Outcome
	}

	if val := reflect.ValueOf(b.Provider); !val.IsZero() {
		res["provider"] = b.Provider
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.RiskScore); !val.IsZero() {
		res["risk_score"] = b.RiskScore
	}

	if val := reflect.ValueOf(b.RiskScoreNorm); !val.IsZero() {
		res["risk_score_norm"] = b.RiskScoreNorm
	}

	if val := reflect.ValueOf(b.Sequence); !val.IsZero() {
		res["sequence"] = b.Sequence
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Timezone); !val.IsZero() {
		res["timezone"] = b.Timezone
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.URL); !val.IsZero() {
		res["url"] = b.URL
	}

	return json.Marshal(res)
}

// File defines the object located at ECS path file.
type File struct {
	Accessed      time.Time         `json:"accessed,omitempty" yaml:"accessed,omitempty" ecs:"file.accessed"`
	Attributes    []string          `json:"attributes,omitempty" yaml:"attributes,omitempty" ecs:"file.attributes"`
	CodeSignature FileCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"file.code_signature"`
	Created       time.Time         `json:"created,omitempty" yaml:"created,omitempty" ecs:"file.created"`
	Ctime         time.Time         `json:"ctime,omitempty" yaml:"ctime,omitempty" ecs:"file.ctime"`
	Device        string            `json:"device,omitempty" yaml:"device,omitempty" ecs:"file.device"`
	Directory     string            `json:"directory,omitempty" yaml:"directory,omitempty" ecs:"file.directory"`
	DriveLetter   string            `json:"drive_letter,omitempty" yaml:"drive_letter,omitempty" ecs:"file.drive_letter"`
	Extension     string            `json:"extension,omitempty" yaml:"extension,omitempty" ecs:"file.extension"`
	Gid           string            `json:"gid,omitempty" yaml:"gid,omitempty" ecs:"file.gid"`
	Group         string            `json:"group,omitempty" yaml:"group,omitempty" ecs:"file.group"`
	Hash          FileHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"file.hash"`
	Inode         string            `json:"inode,omitempty" yaml:"inode,omitempty" ecs:"file.inode"`
	MIMEType      string            `json:"mime_type,omitempty" yaml:"mime_type,omitempty" ecs:"file.mime_type"`
	Mode          string            `json:"mode,omitempty" yaml:"mode,omitempty" ecs:"file.mode"`
	Mtime         time.Time         `json:"mtime,omitempty" yaml:"mtime,omitempty" ecs:"file.mtime"`
	Name          string            `json:"name,omitempty" yaml:"name,omitempty" ecs:"file.name"`
	Owner         string            `json:"owner,omitempty" yaml:"owner,omitempty" ecs:"file.owner"`
	Path          string            `json:"path,omitempty" yaml:"path,omitempty" ecs:"file.path"`
	PE            FilePE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"file.pe"`
	Size          int64             `json:"size,omitempty" yaml:"size,omitempty" ecs:"file.size"`
	TargetPath    string            `json:"target_path,omitempty" yaml:"target_path,omitempty" ecs:"file.target_path"`
	Type          string            `json:"type,omitempty" yaml:"type,omitempty" ecs:"file.type"`
	UID           string            `json:"uid,omitempty" yaml:"uid,omitempty" ecs:"file.uid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b File) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Accessed); !val.IsZero() {
		res["accessed"] = b.Accessed
	}

	if val := reflect.ValueOf(b.Attributes); !val.IsZero() {
		res["attributes"] = b.Attributes
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.Created); !val.IsZero() {
		res["created"] = b.Created
	}

	if val := reflect.ValueOf(b.Ctime); !val.IsZero() {
		res["ctime"] = b.Ctime
	}

	if val := reflect.ValueOf(b.Device); !val.IsZero() {
		res["device"] = b.Device
	}

	if val := reflect.ValueOf(b.Directory); !val.IsZero() {
		res["directory"] = b.Directory
	}

	if val := reflect.ValueOf(b.DriveLetter); !val.IsZero() {
		res["drive_letter"] = b.DriveLetter
	}

	if val := reflect.ValueOf(b.Extension); !val.IsZero() {
		res["extension"] = b.Extension
	}

	if val := reflect.ValueOf(b.Gid); !val.IsZero() {
		res["gid"] = b.Gid
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Inode); !val.IsZero() {
		res["inode"] = b.Inode
	}

	if val := reflect.ValueOf(b.MIMEType); !val.IsZero() {
		res["mime_type"] = b.MIMEType
	}

	if val := reflect.ValueOf(b.Mode); !val.IsZero() {
		res["mode"] = b.Mode
	}

	if val := reflect.ValueOf(b.Mtime); !val.IsZero() {
		res["mtime"] = b.Mtime
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Owner); !val.IsZero() {
		res["owner"] = b.Owner
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.Size); !val.IsZero() {
		res["size"] = b.Size
	}

	if val := reflect.ValueOf(b.TargetPath); !val.IsZero() {
		res["target_path"] = b.TargetPath
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.UID); !val.IsZero() {
		res["uid"] = b.UID
	}

	return json.Marshal(res)
}

// FileCodeSignature defines the object located at ECS path file.code_signature.
type FileCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"file.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"file.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"file.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"file.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"file.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// FileHash defines the object located at ECS path file.hash.
type FileHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"file.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"file.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"file.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"file.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// FilePE defines the object located at ECS path file.pe.
type FilePE struct {
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"file.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"file.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"file.pe.file_version"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"file.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"file.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FilePE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// Geo defines the object located at ECS path geo.
type Geo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Geo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// Group defines the object located at ECS path group.
type Group struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Group) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Hash defines the object located at ECS path hash.
type Hash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Hash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// Host defines the object located at ECS path host.
type Host struct {
	Architecture string   `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"host.architecture"`
	Domain       string   `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.domain"`
	Geo          HostGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"host.geo"`
	Hostname     string   `json:"hostname,omitempty" yaml:"hostname,omitempty" ecs:"host.hostname"`
	ID           string   `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.id"`
	IP           []string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"host.ip"`
	MAC          []string `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"host.mac"`
	Name         string   `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.name"`
	OS           HostOS   `json:"os,omitempty" yaml:"os,omitempty" ecs:"host.os"`
	Type         string   `json:"type,omitempty" yaml:"type,omitempty" ecs:"host.type"`
	Uptime       int64    `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"host.uptime"`
	User         HostUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"host.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Host) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.Hostname); !val.IsZero() {
		res["hostname"] = b.Hostname
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// HostGeo defines the object located at ECS path host.geo.
type HostGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"host.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"host.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"host.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"host.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"host.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"host.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"host.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// HostOS defines the object located at ECS path host.os.
type HostOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"host.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"host.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"host.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"host.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"host.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// HostUser defines the object located at ECS path host.user.
type HostUser struct {
	Domain   string        `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.user.domain"`
	Email    string        `json:"email,omitempty" yaml:"email,omitempty" ecs:"host.user.email"`
	FullName string        `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"host.user.full_name"`
	Group    HostUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"host.user.group"`
	Hash     string        `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"host.user.hash"`
	ID       string        `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.user.id"`
	Name     string        `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// HostUserGroup defines the object located at ECS path host.user.group.
type HostUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// HTTP defines the object located at ECS path http.
type HTTP struct {
	Request  HTTPRequest  `json:"request,omitempty" yaml:"request,omitempty" ecs:"http.request"`
	Response HTTPResponse `json:"response,omitempty" yaml:"response,omitempty" ecs:"http.response"`
	Version  string       `json:"version,omitempty" yaml:"version,omitempty" ecs:"http.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTP) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Request); !val.IsZero() {
		res["request"] = b.Request
	}

	if val := reflect.ValueOf(b.Response); !val.IsZero() {
		res["response"] = b.Response
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// HTTPRequest defines the object located at ECS path http.request.
type HTTPRequest struct {
	Body     HTTPRequestBody `json:"body,omitempty" yaml:"body,omitempty" ecs:"http.request.body"`
	Bytes    int64           `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.request.bytes"`
	Method   string          `json:"method,omitempty" yaml:"method,omitempty" ecs:"http.request.method"`
	Referrer string          `json:"referrer,omitempty" yaml:"referrer,omitempty" ecs:"http.request.referrer"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPRequest) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Body); !val.IsZero() {
		res["body"] = b.Body
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Method); !val.IsZero() {
		res["method"] = b.Method
	}

	if val := reflect.ValueOf(b.Referrer); !val.IsZero() {
		res["referrer"] = b.Referrer
	}

	return json.Marshal(res)
}

// HTTPRequestBody defines the object located at ECS path http.request.body.
type HTTPRequestBody struct {
	Bytes   int64  `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.request.body.bytes"`
	Content string `json:"content,omitempty" yaml:"content,omitempty" ecs:"http.request.body.content"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPRequestBody) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Content); !val.IsZero() {
		res["content"] = b.Content
	}

	return json.Marshal(res)
}

// HTTPResponse defines the object located at ECS path http.response.
type HTTPResponse struct {
	Body       HTTPResponseBody `json:"body,omitempty" yaml:"body,omitempty" ecs:"http.response.body"`
	Bytes      int64            `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.response.bytes"`
	StatusCode int64            `json:"status_code,omitempty" yaml:"status_code,omitempty" ecs:"http.response.status_code"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPResponse) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Body); !val.IsZero() {
		res["body"] = b.Body
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.StatusCode); !val.IsZero() {
		res["status_code"] = b.StatusCode
	}

	return json.Marshal(res)
}

// HTTPResponseBody defines the object located at ECS path http.response.body.
type HTTPResponseBody struct {
	Bytes   int64  `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.response.body.bytes"`
	Content string `json:"content,omitempty" yaml:"content,omitempty" ecs:"http.response.body.content"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPResponseBody) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Content); !val.IsZero() {
		res["content"] = b.Content
	}

	return json.Marshal(res)
}

// Interface defines the object located at ECS path interface.
type Interface struct {
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" ecs:"interface.alias"`
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"interface.id"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"interface.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Interface) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Alias); !val.IsZero() {
		res["alias"] = b.Alias
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Log defines the object located at ECS path log.
type Log struct {
	Level    string    `json:"level,omitempty" yaml:"level,omitempty" ecs:"log.level"`
	Logger   string    `json:"logger,omitempty" yaml:"logger,omitempty" ecs:"log.logger"`
	Origin   LogOrigin `json:"origin,omitempty" yaml:"origin,omitempty" ecs:"log.origin"`
	Original string    `json:"original,omitempty" yaml:"original,omitempty" ecs:"log.original"`
	Syslog   LogSyslog `json:"syslog,omitempty" yaml:"syslog,omitempty" ecs:"log.syslog"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Log) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Level); !val.IsZero() {
		res["level"] = b.Level
	}

	if val := reflect.ValueOf(b.Logger); !val.IsZero() {
		res["logger"] = b.Logger
	}

	if val := reflect.ValueOf(b.Origin); !val.IsZero() {
		res["origin"] = b.Origin
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Syslog); !val.IsZero() {
		res["syslog"] = b.Syslog
	}

	return json.Marshal(res)
}

// LogOrigin defines the object located at ECS path log.origin.
type LogOrigin struct {
	File     LogOriginFile `json:"file,omitempty" yaml:"file,omitempty" ecs:"log.origin.file"`
	Function string        `json:"function,omitempty" yaml:"function,omitempty" ecs:"log.origin.function"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogOrigin) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.File); !val.IsZero() {
		res["file"] = b.File
	}

	if val := reflect.ValueOf(b.Function); !val.IsZero() {
		res["function"] = b.Function
	}

	return json.Marshal(res)
}

// LogOriginFile defines the object located at ECS path log.origin.file.
type LogOriginFile struct {
	Line int32  `json:"line,omitempty" yaml:"line,omitempty" ecs:"log.origin.file.line"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.origin.file.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogOriginFile) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Line); !val.IsZero() {
		res["line"] = b.Line
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// LogSyslog defines the object located at ECS path log.syslog.
type LogSyslog struct {
	Facility LogSyslogFacility `json:"facility,omitempty" yaml:"facility,omitempty" ecs:"log.syslog.facility"`
	Priority int64             `json:"priority,omitempty" yaml:"priority,omitempty" ecs:"log.syslog.priority"`
	Severity LogSyslogSeverity `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"log.syslog.severity"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslog) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Facility); !val.IsZero() {
		res["facility"] = b.Facility
	}

	if val := reflect.ValueOf(b.Priority); !val.IsZero() {
		res["priority"] = b.Priority
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	return json.Marshal(res)
}

// LogSyslogFacility defines the object located at ECS path log.syslog.facility.
type LogSyslogFacility struct {
	Code int64  `json:"code,omitempty" yaml:"code,omitempty" ecs:"log.syslog.facility.code"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.syslog.facility.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslogFacility) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// LogSyslogSeverity defines the object located at ECS path log.syslog.severity.
type LogSyslogSeverity struct {
	Code int64  `json:"code,omitempty" yaml:"code,omitempty" ecs:"log.syslog.severity.code"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.syslog.severity.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslogSeverity) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Network defines the object located at ECS path network.
type Network struct {
	Application string       `json:"application,omitempty" yaml:"application,omitempty" ecs:"network.application"`
	Bytes       int64        `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"network.bytes"`
	CommunityID string       `json:"community_id,omitempty" yaml:"community_id,omitempty" ecs:"network.community_id"`
	Direction   string       `json:"direction,omitempty" yaml:"direction,omitempty" ecs:"network.direction"`
	ForwardedIP string       `json:"forwarded_ip,omitempty" yaml:"forwarded_ip,omitempty" ecs:"network.forwarded_ip"`
	IANANumber  string       `json:"iana_number,omitempty" yaml:"iana_number,omitempty" ecs:"network.iana_number"`
	Inner       NetworkInner `json:"inner,omitempty" yaml:"inner,omitempty" ecs:"network.inner"`
	Name        string       `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.name"`
	Packets     int64        `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"network.packets"`
	Protocol    string       `json:"protocol,omitempty" yaml:"protocol,omitempty" ecs:"network.protocol"`
	Transport   string       `json:"transport,omitempty" yaml:"transport,omitempty" ecs:"network.transport"`
	Type        string       `json:"type,omitempty" yaml:"type,omitempty" ecs:"network.type"`
	VLAN        NetworkVLAN  `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"network.vlan"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Network) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Application); !val.IsZero() {
		res["application"] = b.Application
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.CommunityID); !val.IsZero() {
		res["community_id"] = b.CommunityID
	}

	if val := reflect.ValueOf(b.Direction); !val.IsZero() {
		res["direction"] = b.Direction
	}

	if val := reflect.ValueOf(b.ForwardedIP); !val.IsZero() {
		res["forwarded_ip"] = b.ForwardedIP
	}

	if val := reflect.ValueOf(b.IANANumber); !val.IsZero() {
		res["iana_number"] = b.IANANumber
	}

	if val := reflect.ValueOf(b.Inner); !val.IsZero() {
		res["inner"] = b.Inner
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Protocol); !val.IsZero() {
		res["protocol"] = b.Protocol
	}

	if val := reflect.ValueOf(b.Transport); !val.IsZero() {
		res["transport"] = b.Transport
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	return json.Marshal(res)
}

// NetworkInner defines the object located at ECS path network.inner.
type NetworkInner struct {
	VLAN NetworkInnerVLAN `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"network.inner.vlan"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkInner) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	return json.Marshal(res)
}

// NetworkInnerVLAN defines the object located at ECS path network.inner.vlan.
type NetworkInnerVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"network.inner.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.inner.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkInnerVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// NetworkVLAN defines the object located at ECS path network.vlan.
type NetworkVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"network.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Observer defines the object located at ECS path observer.
type Observer struct {
	Egress       ObserverEgress  `json:"egress,omitempty" yaml:"egress,omitempty" ecs:"observer.egress"`
	Geo          ObserverGeo     `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"observer.geo"`
	Hostname     string          `json:"hostname,omitempty" yaml:"hostname,omitempty" ecs:"observer.hostname"`
	Ingress      ObserverIngress `json:"ingress,omitempty" yaml:"ingress,omitempty" ecs:"observer.ingress"`
	IP           []string        `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"observer.ip"`
	MAC          []string        `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"observer.mac"`
	Name         string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.name"`
	OS           ObserverOS      `json:"os,omitempty" yaml:"os,omitempty" ecs:"observer.os"`
	Product      string          `json:"product,omitempty" yaml:"product,omitempty" ecs:"observer.product"`
	SerialNumber string          `json:"serial_number,omitempty" yaml:"serial_number,omitempty" ecs:"observer.serial_number"`
	Type         string          `json:"type,omitempty" yaml:"type,omitempty" ecs:"observer.type"`
	Vendor       string          `json:"vendor,omitempty" yaml:"vendor,omitempty" ecs:"observer.vendor"`
	Version      string          `json:"version,omitempty" yaml:"version,omitempty" ecs:"observer.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Observer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Egress); !val.IsZero() {
		res["egress"] = b.Egress
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.Hostname); !val.IsZero() {
		res["hostname"] = b.Hostname
	}

	if val := reflect.ValueOf(b.Ingress); !val.IsZero() {
		res["ingress"] = b.Ingress
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	if val := reflect.ValueOf(b.SerialNumber); !val.IsZero() {
		res["serial_number"] = b.SerialNumber
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Vendor); !val.IsZero() {
		res["vendor"] = b.Vendor
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// ObserverEgress defines the object located at ECS path observer.egress.
type ObserverEgress struct {
	Interface ObserverEgressInterface `json:"interface,omitempty" yaml:"interface,omitempty" ecs:"observer.egress.interface"`
	VLAN      ObserverEgressVLAN      `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"observer.egress.vlan"`
	Zone      string                  `json:"zone,omitempty" yaml:"zone,omitempty" ecs:"observer.egress.zone"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgress) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Interface); !val.IsZero() {
		res["interface"] = b.Interface
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	if val := reflect.ValueOf(b.Zone); !val.IsZero() {
		res["zone"] = b.Zone
	}

	return json.Marshal(res)
}

// ObserverEgressInterface defines the object located at ECS path observer.egress.interface.
type ObserverEgressInterface struct {
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" ecs:"observer.egress.interface.alias"`
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.egress.interface.id"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.egress.interface.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgressInterface) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Alias); !val.IsZero() {
		res["alias"] = b.Alias
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverEgressVLAN defines the object located at ECS path observer.egress.vlan.
type ObserverEgressVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.egress.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.egress.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgressVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverGeo defines the object located at ECS path observer.geo.
type ObserverGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"observer.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"observer.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"observer.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"observer.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"observer.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"observer.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"observer.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// ObserverIngress defines the object located at ECS path observer.ingress.
type ObserverIngress struct {
	Interface ObserverIngressInterface `json:"interface,omitempty" yaml:"interface,omitempty" ecs:"observer.ingress.interface"`
	VLAN      ObserverIngressVLAN      `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"observer.ingress.vlan"`
	Zone      string                   `json:"zone,omitempty" yaml:"zone,omitempty" ecs:"observer.ingress.zone"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngress) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Interface); !val.IsZero() {
		res["interface"] = b.Interface
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	if val := reflect.ValueOf(b.Zone); !val.IsZero() {
		res["zone"] = b.Zone
	}

	return json.Marshal(res)
}

// ObserverIngressInterface defines the object located at ECS path observer.ingress.interface.
type ObserverIngressInterface struct {
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" ecs:"observer.ingress.interface.alias"`
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.ingress.interface.id"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.ingress.interface.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngressInterface) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Alias); !val.IsZero() {
		res["alias"] = b.Alias
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverIngressVLAN defines the object located at ECS path observer.ingress.vlan.
type ObserverIngressVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.ingress.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.ingress.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngressVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverOS defines the object located at ECS path observer.os.
type ObserverOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"observer.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"observer.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"observer.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"observer.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"observer.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Organization defines the object located at ECS path organization.
type Organization struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"organization.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Organization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// OS defines the object located at ECS path os.
type OS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b OS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Package defines the object located at ECS path package.
type Package struct {
	Architecture string    `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"package.architecture"`
	BuildVersion string    `json:"build_version,omitempty" yaml:"build_version,omitempty" ecs:"package.build_version"`
	Checksum     string    `json:"checksum,omitempty" yaml:"checksum,omitempty" ecs:"package.checksum"`
	Description  string    `json:"description,omitempty" yaml:"description,omitempty" ecs:"package.description"`
	InstallScope string    `json:"install_scope,omitempty" yaml:"install_scope,omitempty" ecs:"package.install_scope"`
	Installed    time.Time `json:"installed,omitempty" yaml:"installed,omitempty" ecs:"package.installed"`
	License      string    `json:"license,omitempty" yaml:"license,omitempty" ecs:"package.license"`
	Name         string    `json:"name,omitempty" yaml:"name,omitempty" ecs:"package.name"`
	Path         string    `json:"path,omitempty" yaml:"path,omitempty" ecs:"package.path"`
	Reference    string    `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"package.reference"`
	Size         int64     `json:"size,omitempty" yaml:"size,omitempty" ecs:"package.size"`
	Type         string    `json:"type,omitempty" yaml:"type,omitempty" ecs:"package.type"`
	Version      string    `json:"version,omitempty" yaml:"version,omitempty" ecs:"package.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Package) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.BuildVersion); !val.IsZero() {
		res["build_version"] = b.BuildVersion
	}

	if val := reflect.ValueOf(b.Checksum); !val.IsZero() {
		res["checksum"] = b.Checksum
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.InstallScope); !val.IsZero() {
		res["install_scope"] = b.InstallScope
	}

	if val := reflect.ValueOf(b.Installed); !val.IsZero() {
		res["installed"] = b.Installed
	}

	if val := reflect.ValueOf(b.License); !val.IsZero() {
		res["license"] = b.License
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.Size); !val.IsZero() {
		res["size"] = b.Size
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// PE defines the object located at ECS path pe.
type PE struct {
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"pe.file_version"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b PE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// Process defines the object located at ECS path process.
type Process struct {
	Args             [][]string           `json:"args,omitempty" yaml:"args,omitempty" ecs:"process.args"`
	ArgsCount        int64                `json:"args_count,omitempty" yaml:"args_count,omitempty" ecs:"process.args_count"`
	CodeSignature    ProcessCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"process.code_signature"`
	CommandLine      string               `json:"command_line,omitempty" yaml:"command_line,omitempty" ecs:"process.command_line"`
	EntityID         string               `json:"entity_id,omitempty" yaml:"entity_id,omitempty" ecs:"process.entity_id"`
	Executable       string               `json:"executable,omitempty" yaml:"executable,omitempty" ecs:"process.executable"`
	ExitCode         int64                `json:"exit_code,omitempty" yaml:"exit_code,omitempty" ecs:"process.exit_code"`
	Hash             ProcessHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"process.hash"`
	Name             string               `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.name"`
	Parent           ProcessParent        `json:"parent,omitempty" yaml:"parent,omitempty" ecs:"process.parent"`
	PE               ProcessPE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"process.pe"`
	PGID             int64                `json:"pgid,omitempty" yaml:"pgid,omitempty" ecs:"process.pgid"`
	PID              int64                `json:"pid,omitempty" yaml:"pid,omitempty" ecs:"process.pid"`
	PPID             int64                `json:"ppid,omitempty" yaml:"ppid,omitempty" ecs:"process.ppid"`
	Start            time.Time            `json:"start,omitempty" yaml:"start,omitempty" ecs:"process.start"`
	Thread           ProcessThread        `json:"thread,omitempty" yaml:"thread,omitempty" ecs:"process.thread"`
	Title            string               `json:"title,omitempty" yaml:"title,omitempty" ecs:"process.title"`
	Uptime           int64                `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"process.uptime"`
	WorkingDirectory string               `json:"working_directory,omitempty" yaml:"working_directory,omitempty" ecs:"process.working_directory"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Process) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Args); !val.IsZero() {
		res["args"] = b.Args
	}

	if val := reflect.ValueOf(b.ArgsCount); !val.IsZero() {
		res["args_count"] = b.ArgsCount
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.CommandLine); !val.IsZero() {
		res["command_line"] = b.CommandLine
	}

	if val := reflect.ValueOf(b.EntityID); !val.IsZero() {
		res["entity_id"] = b.EntityID
	}

	if val := reflect.ValueOf(b.Executable); !val.IsZero() {
		res["executable"] = b.Executable
	}

	if val := reflect.ValueOf(b.ExitCode); !val.IsZero() {
		res["exit_code"] = b.ExitCode
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Parent); !val.IsZero() {
		res["parent"] = b.Parent
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.PGID); !val.IsZero() {
		res["pgid"] = b.PGID
	}

	if val := reflect.ValueOf(b.PID); !val.IsZero() {
		res["pid"] = b.PID
	}

	if val := reflect.ValueOf(b.PPID); !val.IsZero() {
		res["ppid"] = b.PPID
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Thread); !val.IsZero() {
		res["thread"] = b.Thread
	}

	if val := reflect.ValueOf(b.Title); !val.IsZero() {
		res["title"] = b.Title
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.WorkingDirectory); !val.IsZero() {
		res["working_directory"] = b.WorkingDirectory
	}

	return json.Marshal(res)
}

// ProcessCodeSignature defines the object located at ECS path process.code_signature.
type ProcessCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"process.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"process.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"process.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"process.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"process.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// ProcessHash defines the object located at ECS path process.hash.
type ProcessHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"process.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"process.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"process.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"process.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// ProcessParent defines the object located at ECS path process.parent.
type ProcessParent struct {
	Args             [][]string                 `json:"args,omitempty" yaml:"args,omitempty" ecs:"process.parent.args"`
	ArgsCount        int64                      `json:"args_count,omitempty" yaml:"args_count,omitempty" ecs:"process.parent.args_count"`
	CodeSignature    ProcessParentCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"process.parent.code_signature"`
	CommandLine      string                     `json:"command_line,omitempty" yaml:"command_line,omitempty" ecs:"process.parent.command_line"`
	EntityID         string                     `json:"entity_id,omitempty" yaml:"entity_id,omitempty" ecs:"process.parent.entity_id"`
	Executable       string                     `json:"executable,omitempty" yaml:"executable,omitempty" ecs:"process.parent.executable"`
	ExitCode         int64                      `json:"exit_code,omitempty" yaml:"exit_code,omitempty" ecs:"process.parent.exit_code"`
	Hash             ProcessParentHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"process.parent.hash"`
	Name             string                     `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.parent.name"`
	PGID             int64                      `json:"pgid,omitempty" yaml:"pgid,omitempty" ecs:"process.parent.pgid"`
	PID              int64                      `json:"pid,omitempty" yaml:"pid,omitempty" ecs:"process.parent.pid"`
	PPID             int64                      `json:"ppid,omitempty" yaml:"ppid,omitempty" ecs:"process.parent.ppid"`
	Start            time.Time                  `json:"start,omitempty" yaml:"start,omitempty" ecs:"process.parent.start"`
	Thread           ProcessParentThread        `json:"thread,omitempty" yaml:"thread,omitempty" ecs:"process.parent.thread"`
	Title            string                     `json:"title,omitempty" yaml:"title,omitempty" ecs:"process.parent.title"`
	Uptime           int64                      `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"process.parent.uptime"`
	WorkingDirectory string                     `json:"working_directory,omitempty" yaml:"working_directory,omitempty" ecs:"process.parent.working_directory"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Args); !val.IsZero() {
		res["args"] = b.Args
	}

	if val := reflect.ValueOf(b.ArgsCount); !val.IsZero() {
		res["args_count"] = b.ArgsCount
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.CommandLine); !val.IsZero() {
		res["command_line"] = b.CommandLine
	}

	if val := reflect.ValueOf(b.EntityID); !val.IsZero() {
		res["entity_id"] = b.EntityID
	}

	if val := reflect.ValueOf(b.Executable); !val.IsZero() {
		res["executable"] = b.Executable
	}

	if val := reflect.ValueOf(b.ExitCode); !val.IsZero() {
		res["exit_code"] = b.ExitCode
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.PGID); !val.IsZero() {
		res["pgid"] = b.PGID
	}

	if val := reflect.ValueOf(b.PID); !val.IsZero() {
		res["pid"] = b.PID
	}

	if val := reflect.ValueOf(b.PPID); !val.IsZero() {
		res["ppid"] = b.PPID
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Thread); !val.IsZero() {
		res["thread"] = b.Thread
	}

	if val := reflect.ValueOf(b.Title); !val.IsZero() {
		res["title"] = b.Title
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.WorkingDirectory); !val.IsZero() {
		res["working_directory"] = b.WorkingDirectory
	}

	return json.Marshal(res)
}

// ProcessParentCodeSignature defines the object located at ECS path process.parent.code_signature.
type ProcessParentCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"process.parent.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"process.parent.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"process.parent.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"process.parent.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"process.parent.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// ProcessParentHash defines the object located at ECS path process.parent.hash.
type ProcessParentHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"process.parent.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"process.parent.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"process.parent.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"process.parent.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// ProcessParentThread defines the object located at ECS path process.parent.thread.
type ProcessParentThread struct {
	ID   int64  `json:"id,omitempty" yaml:"id,omitempty" ecs:"process.parent.thread.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.parent.thread.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentThread) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ProcessPE defines the object located at ECS path process.pe.
type ProcessPE struct {
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"process.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"process.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"process.pe.file_version"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"process.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"process.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessPE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// ProcessThread defines the object located at ECS path process.thread.
type ProcessThread struct {
	ID   int64  `json:"id,omitempty" yaml:"id,omitempty" ecs:"process.thread.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.thread.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessThread) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Registry defines the object located at ECS path registry.
type Registry struct {
	Data  RegistryData `json:"data,omitempty" yaml:"data,omitempty" ecs:"registry.data"`
	Hive  string       `json:"hive,omitempty" yaml:"hive,omitempty" ecs:"registry.hive"`
	Key   string       `json:"key,omitempty" yaml:"key,omitempty" ecs:"registry.key"`
	Path  string       `json:"path,omitempty" yaml:"path,omitempty" ecs:"registry.path"`
	Value string       `json:"value,omitempty" yaml:"value,omitempty" ecs:"registry.value"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Registry) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Data); !val.IsZero() {
		res["data"] = b.Data
	}

	if val := reflect.ValueOf(b.Hive); !val.IsZero() {
		res["hive"] = b.Hive
	}

	if val := reflect.ValueOf(b.Key); !val.IsZero() {
		res["key"] = b.Key
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Value); !val.IsZero() {
		res["value"] = b.Value
	}

	return json.Marshal(res)
}

// RegistryData defines the object located at ECS path registry.data.
type RegistryData struct {
	Bytes   string `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"registry.data.bytes"`
	Strings string `json:"strings,omitempty" yaml:"strings,omitempty" ecs:"registry.data.strings"`
	Type    string `json:"type,omitempty" yaml:"type,omitempty" ecs:"registry.data.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b RegistryData) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Strings); !val.IsZero() {
		res["strings"] = b.Strings
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// Related defines the object located at ECS path related.
type Related struct {
	Hash []string `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"related.hash"`
	IP   []string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"related.ip"`
	User []string `json:"user,omitempty" yaml:"user,omitempty" ecs:"related.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Related) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// Rule defines the object located at ECS path rule.
type Rule struct {
	Author      []string `json:"author,omitempty" yaml:"author,omitempty" ecs:"rule.author"`
	Category    string   `json:"category,omitempty" yaml:"category,omitempty" ecs:"rule.category"`
	Description string   `json:"description,omitempty" yaml:"description,omitempty" ecs:"rule.description"`
	ID          string   `json:"id,omitempty" yaml:"id,omitempty" ecs:"rule.id"`
	License     string   `json:"license,omitempty" yaml:"license,omitempty" ecs:"rule.license"`
	Name        string   `json:"name,omitempty" yaml:"name,omitempty" ecs:"rule.name"`
	Reference   string   `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"rule.reference"`
	Ruleset     string   `json:"ruleset,omitempty" yaml:"ruleset,omitempty" ecs:"rule.ruleset"`
	UUID        string   `json:"uuid,omitempty" yaml:"uuid,omitempty" ecs:"rule.uuid"`
	Version     string   `json:"version,omitempty" yaml:"version,omitempty" ecs:"rule.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Rule) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Author); !val.IsZero() {
		res["author"] = b.Author
	}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.License); !val.IsZero() {
		res["license"] = b.License
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.Ruleset); !val.IsZero() {
		res["ruleset"] = b.Ruleset
	}

	if val := reflect.ValueOf(b.UUID); !val.IsZero() {
		res["uuid"] = b.UUID
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Search defines the object located at ECS path search.
type Search struct {
	Query   SearchQuery   `json:"query,omitempty" yaml:"query,omitempty" ecs:"search.query"`
	Results SearchResults `json:"results,omitempty" yaml:"results,omitempty" ecs:"search.results"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Search) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Query); !val.IsZero() {
		res["query"] = b.Query
	}

	if val := reflect.ValueOf(b.Results); !val.IsZero() {
		res["results"] = b.Results
	}

	return json.Marshal(res)
}

// SearchQuery defines the object located at ECS path search.query.
type SearchQuery struct {
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"search.query.id"`
	Page  int64  `json:"page,omitempty" yaml:"page,omitempty" ecs:"search.query.page"`
	Value string `json:"value,omitempty" yaml:"value,omitempty" ecs:"search.query.value"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SearchQuery) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Page); !val.IsZero() {
		res["page"] = b.Page
	}

	if val := reflect.ValueOf(b.Value); !val.IsZero() {
		res["value"] = b.Value
	}

	return json.Marshal(res)
}

// SearchResults defines the object located at ECS path search.results.
type SearchResults struct {
	Ids   []string `json:"ids,omitempty" yaml:"ids,omitempty" ecs:"search.results.ids"`
	Size  int64    `json:"size,omitempty" yaml:"size,omitempty" ecs:"search.results.size"`
	Total int64    `json:"total,omitempty" yaml:"total,omitempty" ecs:"search.results.total"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SearchResults) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Ids); !val.IsZero() {
		res["ids"] = b.Ids
	}

	if val := reflect.ValueOf(b.Size); !val.IsZero() {
		res["size"] = b.Size
	}

	if val := reflect.ValueOf(b.Total); !val.IsZero() {
		res["total"] = b.Total
	}

	return json.Marshal(res)
}

// Server defines the object located at ECS path server.
type Server struct {
	Address          string     `json:"address,omitempty" yaml:"address,omitempty" ecs:"server.address"`
	AS               ServerAS   `json:"as,omitempty" yaml:"as,omitempty" ecs:"server.as"`
	Bytes            int64      `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"server.bytes"`
	Domain           string     `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.domain"`
	Geo              ServerGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"server.geo"`
	IP               string     `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"server.ip"`
	MAC              string     `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"server.mac"`
	NAT              ServerNAT  `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"server.nat"`
	Packets          int64      `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"server.packets"`
	Port             int64      `json:"port,omitempty" yaml:"port,omitempty" ecs:"server.port"`
	RegisteredDomain string     `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"server.registered_domain"`
	TopLevelDomain   string     `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"server.top_level_domain"`
	User             ServerUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"server.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Server) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// ServerAS defines the object located at ECS path server.as.
type ServerAS struct {
	Number       int64                `json:"number,omitempty" yaml:"number,omitempty" ecs:"server.as.number"`
	Organization ServerASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"server.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// ServerASOrganization defines the object located at ECS path server.as.organization.
type ServerASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ServerGeo defines the object located at ECS path server.geo.
type ServerGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"server.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"server.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"server.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"server.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"server.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"server.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"server.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// ServerNAT defines the object located at ECS path server.nat.
type ServerNAT struct {
	IP   string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"server.nat.ip"`
	Port int64  `json:"port,omitempty" yaml:"port,omitempty" ecs:"server.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// ServerUser defines the object located at ECS path server.user.
type ServerUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"server.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"server.user.full_name"`
	Group    ServerUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"server.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"server.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"server.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ServerUserGroup defines the object located at ECS path server.user.group.
type ServerUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"server.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Service defines the object located at ECS path service.
type Service struct {
	EphemeralID string      `json:"ephemeral_id,omitempty" yaml:"ephemeral_id,omitempty" ecs:"service.ephemeral_id"`
	ID          string      `json:"id,omitempty" yaml:"id,omitempty" ecs:"service.id"`
	Name        string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"service.name"`
	Node        ServiceNode `json:"node,omitempty" yaml:"node,omitempty" ecs:"service.node"`
	State       string      `json:"state,omitempty" yaml:"state,omitempty" ecs:"service.state"`
	Type        string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"service.type"`
	Version     string      `json:"version,omitempty" yaml:"version,omitempty" ecs:"service.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Service) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.EphemeralID); !val.IsZero() {
		res["ephemeral_id"] = b.EphemeralID
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Node); !val.IsZero() {
		res["node"] = b.Node
	}

	if val := reflect.ValueOf(b.State); !val.IsZero() {
		res["state"] = b.State
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// ServiceNode defines the object located at ECS path service.node.
type ServiceNode struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"service.node.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServiceNode) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Source defines the object located at ECS path source.
type Source struct {
	Address          string     `json:"address,omitempty" yaml:"address,omitempty" ecs:"source.address"`
	AS               SourceAS   `json:"as,omitempty" yaml:"as,omitempty" ecs:"source.as"`
	Bytes            int64      `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"source.bytes"`
	Domain           string     `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.domain"`
	Geo              SourceGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"source.geo"`
	IP               string     `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"source.ip"`
	MAC              string     `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"source.mac"`
	NAT              SourceNAT  `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"source.nat"`
	Packets          int64      `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"source.packets"`
	Port             int64      `json:"port,omitempty" yaml:"port,omitempty" ecs:"source.port"`
	RegisteredDomain string     `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"source.registered_domain"`
	TopLevelDomain   string     `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"source.top_level_domain"`
	User             SourceUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"source.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Source) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// SourceAS defines the object located at ECS path source.as.
type SourceAS struct {
	Number       int64                `json:"number,omitempty" yaml:"number,omitempty" ecs:"source.as.number"`
	Organization SourceASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"source.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// SourceASOrganization defines the object located at ECS path source.as.organization.
type SourceASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// SourceGeo defines the object located at ECS path source.geo.
type SourceGeo struct {
	CityName       string `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"source.geo.city_name"`
	ContinentName  string `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"source.geo.continent_name"`
	CountryISOCode string `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"source.geo.country_iso_code"`
	CountryName    string `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"source.geo.country_name"`
	Location       string `json:"location,omitempty" yaml:"location,omitempty" ecs:"source.geo.location"`
	Name           string `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.geo.name"`
	RegionISOCode  string `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"source.geo.region_iso_code"`
	RegionName     string `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"source.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// SourceNAT defines the object located at ECS path source.nat.
type SourceNAT struct {
	IP   string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"source.nat.ip"`
	Port int64  `json:"port,omitempty" yaml:"port,omitempty" ecs:"source.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// SourceUser defines the object located at ECS path source.user.
type SourceUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"source.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"source.user.full_name"`
	Group    SourceUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"source.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"source.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"source.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// SourceUserGroup defines the object located at ECS path source.user.group.
type SourceUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"source.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Threat defines the object located at ECS path threat.
type Threat struct {
	Framework string          `json:"framework,omitempty" yaml:"framework,omitempty" ecs:"threat.framework"`
	Tactic    ThreatTactic    `json:"tactic,omitempty" yaml:"tactic,omitempty" ecs:"threat.tactic"`
	Technique ThreatTechnique `json:"technique,omitempty" yaml:"technique,omitempty" ecs:"threat.technique"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Threat) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Framework); !val.IsZero() {
		res["framework"] = b.Framework
	}

	if val := reflect.ValueOf(b.Tactic); !val.IsZero() {
		res["tactic"] = b.Tactic
	}

	if val := reflect.ValueOf(b.Technique); !val.IsZero() {
		res["technique"] = b.Technique
	}

	return json.Marshal(res)
}

// ThreatTactic defines the object located at ECS path threat.tactic.
type ThreatTactic struct {
	ID        []string `json:"id,omitempty" yaml:"id,omitempty" ecs:"threat.tactic.id"`
	Name      []string `json:"name,omitempty" yaml:"name,omitempty" ecs:"threat.tactic.name"`
	Reference []string `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"threat.tactic.reference"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ThreatTactic) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	return json.Marshal(res)
}

// ThreatTechnique defines the object located at ECS path threat.technique.
type ThreatTechnique struct {
	ID        []string `json:"id,omitempty" yaml:"id,omitempty" ecs:"threat.technique.id"`
	Name      []string `json:"name,omitempty" yaml:"name,omitempty" ecs:"threat.technique.name"`
	Reference []string `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"threat.technique.reference"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ThreatTechnique) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	return json.Marshal(res)
}

// TLS defines the object located at ECS path tls.
type TLS struct {
	Cipher          string    `json:"cipher,omitempty" yaml:"cipher,omitempty" ecs:"tls.cipher"`
	Client          TLSClient `json:"client,omitempty" yaml:"client,omitempty" ecs:"tls.client"`
	Curve           string    `json:"curve,omitempty" yaml:"curve,omitempty" ecs:"tls.curve"`
	Established     bool      `json:"established,omitempty" yaml:"established,omitempty" ecs:"tls.established"`
	NextProtocol    string    `json:"next_protocol,omitempty" yaml:"next_protocol,omitempty" ecs:"tls.next_protocol"`
	Resumed         bool      `json:"resumed,omitempty" yaml:"resumed,omitempty" ecs:"tls.resumed"`
	Server          TLSServer `json:"server,omitempty" yaml:"server,omitempty" ecs:"tls.server"`
	Version         string    `json:"version,omitempty" yaml:"version,omitempty" ecs:"tls.version"`
	VersionProtocol string    `json:"version_protocol,omitempty" yaml:"version_protocol,omitempty" ecs:"tls.version_protocol"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Cipher); !val.IsZero() {
		res["cipher"] = b.Cipher
	}

	if val := reflect.ValueOf(b.Client); !val.IsZero() {
		res["client"] = b.Client
	}

	if val := reflect.ValueOf(b.Curve); !val.IsZero() {
		res["curve"] = b.Curve
	}

	if val := reflect.ValueOf(b.Established); !val.IsZero() {
		res["established"] = b.Established
	}

	if val := reflect.ValueOf(b.NextProtocol); !val.IsZero() {
		res["next_protocol"] = b.NextProtocol
	}

	if val := reflect.ValueOf(b.Resumed); !val.IsZero() {
		res["resumed"] = b.Resumed
	}

	if val := reflect.ValueOf(b.Server); !val.IsZero() {
		res["server"] = b.Server
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	if val := reflect.ValueOf(b.VersionProtocol); !val.IsZero() {
		res["version_protocol"] = b.VersionProtocol
	}

	return json.Marshal(res)
}

// TLSClient defines the object located at ECS path tls.client.
type TLSClient struct {
	Certificate      string        `json:"certificate,omitempty" yaml:"certificate,omitempty" ecs:"tls.client.certificate"`
	CertificateChain []string      `json:"certificate_chain,omitempty" yaml:"certificate_chain,omitempty" ecs:"tls.client.certificate_chain"`
	Hash             TLSClientHash `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"tls.client.hash"`
	Issuer           string        `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.client.issuer"`
	JA3              string        `json:"ja3,omitempty" yaml:"ja3,omitempty" ecs:"tls.client.ja3"`
	NotAfter         time.Time     `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.client.not_after"`
	NotBefore        time.Time     `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.client.not_before"`
	ServerName       string        `json:"server_name,omitempty" yaml:"server_name,omitempty" ecs:"tls.client.server_name"`
	Subject          string        `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.client.subject"`
	SupportedCiphers []string      `json:"supported_ciphers,omitempty" yaml:"supported_ciphers,omitempty" ecs:"tls.client.supported_ciphers"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClient) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Certificate); !val.IsZero() {
		res["certificate"] = b.Certificate
	}

	if val := reflect.ValueOf(b.CertificateChain); !val.IsZero() {
		res["certificate_chain"] = b.CertificateChain
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.JA3); !val.IsZero() {
		res["ja3"] = b.JA3
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.ServerName); !val.IsZero() {
		res["server_name"] = b.ServerName
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.SupportedCiphers); !val.IsZero() {
		res["supported_ciphers"] = b.SupportedCiphers
	}

	return json.Marshal(res)
}

// TLSClientHash defines the object located at ECS path tls.client.hash.
type TLSClientHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"tls.client.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"tls.client.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"tls.client.hash.sha256"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClientHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	return json.Marshal(res)
}

// TLSServer defines the object located at ECS path tls.server.
type TLSServer struct {
	Certificate      string        `json:"certificate,omitempty" yaml:"certificate,omitempty" ecs:"tls.server.certificate"`
	CertificateChain []string      `json:"certificate_chain,omitempty" yaml:"certificate_chain,omitempty" ecs:"tls.server.certificate_chain"`
	Hash             TLSServerHash `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"tls.server.hash"`
	Issuer           string        `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.server.issuer"`
	JA3S             string        `json:"ja3s,omitempty" yaml:"ja3s,omitempty" ecs:"tls.server.ja3s"`
	NotAfter         time.Time     `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.server.not_after"`
	NotBefore        time.Time     `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.server.not_before"`
	Subject          string        `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.server.subject"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Certificate); !val.IsZero() {
		res["certificate"] = b.Certificate
	}

	if val := reflect.ValueOf(b.CertificateChain); !val.IsZero() {
		res["certificate_chain"] = b.CertificateChain
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.JA3S); !val.IsZero() {
		res["ja3s"] = b.JA3S
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	return json.Marshal(res)
}

// TLSServerHash defines the object located at ECS path tls.server.hash.
type TLSServerHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"tls.server.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"tls.server.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"tls.server.hash.sha256"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServerHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	return json.Marshal(res)
}

// Trace defines the object located at ECS path trace.
type Trace struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"trace.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Trace) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// Transaction defines the object located at ECS path transaction.
type Transaction struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"transaction.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Transaction) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// URL defines the object located at ECS path url.
type URL struct {
	Domain           string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"url.domain"`
	Extension        string `json:"extension,omitempty" yaml:"extension,omitempty" ecs:"url.extension"`
	Fragment         string `json:"fragment,omitempty" yaml:"fragment,omitempty" ecs:"url.fragment"`
	Full             string `json:"full,omitempty" yaml:"full,omitempty" ecs:"url.full"`
	Original         string `json:"original,omitempty" yaml:"original,omitempty" ecs:"url.original"`
	Password         string `json:"password,omitempty" yaml:"password,omitempty" ecs:"url.password"`
	Path             string `json:"path,omitempty" yaml:"path,omitempty" ecs:"url.path"`
	Port             int64  `json:"port,omitempty" yaml:"port,omitempty" ecs:"url.port"`
	Query            string `json:"query,omitempty" yaml:"query,omitempty" ecs:"url.query"`
	RegisteredDomain string `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"url.registered_domain"`
	Scheme           string `json:"scheme,omitempty" yaml:"scheme,omitempty" ecs:"url.scheme"`
	TopLevelDomain   string `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"url.top_level_domain"`
	Username         string `json:"username,omitempty" yaml:"username,omitempty" ecs:"url.username"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b URL) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Extension); !val.IsZero() {
		res["extension"] = b.Extension
	}

	if val := reflect.ValueOf(b.Fragment); !val.IsZero() {
		res["fragment"] = b.Fragment
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Password); !val.IsZero() {
		res["password"] = b.Password
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.Query); !val.IsZero() {
		res["query"] = b.Query
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.Scheme); !val.IsZero() {
		res["scheme"] = b.Scheme
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.Username); !val.IsZero() {
		res["username"] = b.Username
	}

	return json.Marshal(res)
}

// User defines the object located at ECS path user.
type User struct {
	Domain   string    `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"user.domain"`
	Email    string    `json:"email,omitempty" yaml:"email,omitempty" ecs:"user.email"`
	FullName string    `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"user.full_name"`
	Group    UserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"user.group"`
	Hash     string    `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"user.hash"`
	ID       string    `json:"id,omitempty" yaml:"id,omitempty" ecs:"user.id"`
	Name     string    `json:"name,omitempty" yaml:"name,omitempty" ecs:"user.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b User) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// UserGroup defines the object located at ECS path user.group.
type UserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// UserAgent defines the object located at ECS path user_agent.
type UserAgent struct {
	Device   UserAgentDevice `json:"device,omitempty" yaml:"device,omitempty" ecs:"user_agent.device"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.name"`
	Original string          `json:"original,omitempty" yaml:"original,omitempty" ecs:"user_agent.original"`
	OS       UserAgentOS     `json:"os,omitempty" yaml:"os,omitempty" ecs:"user_agent.os"`
	Version  string          `json:"version,omitempty" yaml:"version,omitempty" ecs:"user_agent.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Device); !val.IsZero() {
		res["device"] = b.Device
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// UserAgentDevice defines the object located at ECS path user_agent.device.
type UserAgentDevice struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.device.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgentDevice) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// UserAgentOS defines the object located at ECS path user_agent.os.
type UserAgentOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"user_agent.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"user_agent.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"user_agent.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"user_agent.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"user_agent.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgentOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// VLAN defines the object located at ECS path vlan.
type VLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b VLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Vulnerability defines the object located at ECS path vulnerability.
type Vulnerability struct {
	Category       []string             `json:"category,omitempty" yaml:"category,omitempty" ecs:"vulnerability.category"`
	Classification string               `json:"classification,omitempty" yaml:"classification,omitempty" ecs:"vulnerability.classification"`
	Description    string               `json:"description,omitempty" yaml:"description,omitempty" ecs:"vulnerability.description"`
	Enumeration    string               `json:"enumeration,omitempty" yaml:"enumeration,omitempty" ecs:"vulnerability.enumeration"`
	ID             string               `json:"id,omitempty" yaml:"id,omitempty" ecs:"vulnerability.id"`
	Reference      string               `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"vulnerability.reference"`
	ReportID       string               `json:"report_id,omitempty" yaml:"report_id,omitempty" ecs:"vulnerability.report_id"`
	Scanner        VulnerabilityScanner `json:"scanner,omitempty" yaml:"scanner,omitempty" ecs:"vulnerability.scanner"`
	Score          VulnerabilityScore   `json:"score,omitempty" yaml:"score,omitempty" ecs:"vulnerability.score"`
	Severity       string               `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"vulnerability.severity"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Vulnerability) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Classification); !val.IsZero() {
		res["classification"] = b.Classification
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.Enumeration); !val.IsZero() {
		res["enumeration"] = b.Enumeration
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.ReportID); !val.IsZero() {
		res["report_id"] = b.ReportID
	}

	if val := reflect.ValueOf(b.Scanner); !val.IsZero() {
		res["scanner"] = b.Scanner
	}

	if val := reflect.ValueOf(b.Score); !val.IsZero() {
		res["score"] = b.Score
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	return json.Marshal(res)
}

// VulnerabilityScanner defines the object located at ECS path vulnerability.scanner.
type VulnerabilityScanner struct {
	Vendor string `json:"vendor,omitempty" yaml:"vendor,omitempty" ecs:"vulnerability.scanner.vendor"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b VulnerabilityScanner) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Vendor); !val.IsZero() {
		res["vendor"] = b.Vendor
	}

	return json.Marshal(res)
}

// VulnerabilityScore defines the object located at ECS path vulnerability.score.
type VulnerabilityScore struct {
	Base          float64 `json:"base,omitempty" yaml:"base,omitempty" ecs:"vulnerability.score.base"`
	Environmental float64 `json:"environmental,omitempty" yaml:"environmental,omitempty" ecs:"vulnerability.score.environmental"`
	Temporal      float64 `json:"temporal,omitempty" yaml:"temporal,omitempty" ecs:"vulnerability.score.temporal"`
	Version       string  `json:"version,omitempty" yaml:"version,omitempty" ecs:"vulnerability.score.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b VulnerabilityScore) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Base); !val.IsZero() {
		res["base"] = b.Base
	}

	if val := reflect.ValueOf(b.Environmental); !val.IsZero() {
		res["environmental"] = b.Environmental
	}

	if val := reflect.ValueOf(b.Temporal); !val.IsZero() {
		res["temporal"] = b.Temporal
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}
